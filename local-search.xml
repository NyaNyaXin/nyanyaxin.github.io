<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ArrayList扩容机制</title>
    <link href="/2020/09/06/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/09/06/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>转自JavaGuide：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md</a></p><h2 id="一-先从-ArrayList-的构造函数说起"><a href="#一-先从-ArrayList-的构造函数说起" class="headerlink" title="一 先从 ArrayList 的构造函数说起"></a>一 先从 ArrayList 的构造函数说起</h2><p><strong>ArrayList有三种方式来初始化，构造方法源码如下：</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">  * 默认初始容量大小</span><span class="hljs-comment">  */</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; <span class="hljs-comment">/**</span><span class="hljs-comment">  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span><span class="hljs-comment">  */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span><span class="hljs-comment">  */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;     <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//初始容量大于0</span>         <span class="hljs-comment">//创建initialCapacity大小的数组</span>         <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//初始容量等于0</span>         <span class="hljs-comment">//创建空数组</span>         <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;     &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//初始容量小于0，抛出异常</span>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+                                            initialCapacity);     &#125; &#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span><span class="hljs-comment"> *如果指定的集合为null，throws NullPointerException。 </span><span class="hljs-comment"> */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;     elementData = c.toArray();     <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;         <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>         <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)             elementData = Arrays.copyOf(elementData, size, Object[].class);     &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-comment">// replace with empty array.</span>         <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;     &#125; &#125;</code></pre><p>细心的同学一定会发现 ：<strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。</strong> 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p><h2 id="二-一步一步分析-ArrayList-扩容机制"><a href="#二-一步一步分析-ArrayList-扩容机制" class="headerlink" title="二 一步一步分析 ArrayList 扩容机制"></a>二 一步一步分析 ArrayList 扩容机制</h2><p>这里以无参构造函数创建的 ArrayList 为例分析</p><h3 id="1-先来看-add-方法"><a href="#1-先来看-add-方法" class="headerlink" title="1. 先来看 add 方法"></a>1. 先来看 <code>add</code> 方法</h3><pre><code class="hljs java"> <span class="hljs-comment">/**</span><span class="hljs-comment">  * 将指定的元素追加到此列表的末尾。 </span><span class="hljs-comment">  */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<span class="hljs-comment">//添加元素之前，先调用ensureCapacityInternal方法</span>     ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>     <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span>     elementData[size++] = e;     <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; &#125;</code></pre><blockquote><p><strong>注意</strong> ：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p></blockquote><h3 id="2-再来看看-ensureCapacityInternal-方法"><a href="#2-再来看看-ensureCapacityInternal-方法" class="headerlink" title="2. 再来看看 ensureCapacityInternal() 方法"></a>2. 再来看看 <code>ensureCapacityInternal()</code> 方法</h3><p>可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p><pre><code class="hljs java"><span class="hljs-comment">//得到最小扩容量</span> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;     <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;           <span class="hljs-comment">// 获取默认的容量和传入参数的较大值</span>         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);     &#125;     ensureExplicitCapacity(minCapacity); &#125;</code></pre><p><strong>当 要 add 进第1个元素时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。</strong></p><h3 id="3-ensureExplicitCapacity-方法"><a href="#3-ensureExplicitCapacity-方法" class="headerlink" title="3. ensureExplicitCapacity() 方法"></a>3. <code>ensureExplicitCapacity()</code> 方法</h3><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进过（执行）这个方法，下面我们来研究一下这个方法的源码！</p><pre><code class="hljs java"><span class="hljs-comment">//判断是否需要扩容</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;      modCount++;      <span class="hljs-comment">// overflow-conscious code</span>      <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)          <span class="hljs-comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span>          grow(minCapacity);  &#125;</code></pre><p>我们来仔细分析一下：</p><ul><li>当我们要 add 进第1个元素到 ArrayList 时，elementData.length 为0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为10。此时，<code>minCapacity - elementData.length &gt; 0 </code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li><li>当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0 </code>不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li><li>添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。</li></ul><p>直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。</p><h3 id="4-grow-方法"><a href="#4-grow-方法" class="headerlink" title="4. grow() 方法"></a>4. <code>grow()</code> 方法</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 要分配的最大数组大小</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="hljs-number">8</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * ArrayList扩容的核心方法。</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span>    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;    <span class="hljs-comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>    <span class="hljs-comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)        newCapacity = minCapacity;   <span class="hljs-comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span>   <span class="hljs-comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)        newCapacity = hugeCapacity(minCapacity);    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span>    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</code></pre><p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity为偶数就是1.5倍，否则是1.5倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源 　</p></blockquote><p><strong>我们再来通过例子探究一下<code>grow()</code> 方法 ：</strong></p><ul><li>当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为10，add方法中 return true,size增为1。</li><li>当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。</li><li>以此类推······</li></ul><p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p><ul><li>java 中的 <code>length </code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li><li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul><h3 id="5-hugeCapacity-方法。"><a href="#5-hugeCapacity-方法。" class="headerlink" title="5. hugeCapacity() 方法。"></a>5. <code>hugeCapacity()</code> 方法。</h3><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();    <span class="hljs-comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span>    <span class="hljs-comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span>    <span class="hljs-comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span>    <span class="hljs-comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?        Integer.MAX_VALUE :        MAX_ARRAY_SIZE;&#125;</code></pre><h2 id="三-System-arraycopy-和-Arrays-copyOf-方法"><a href="#三-System-arraycopy-和-Arrays-copyOf-方法" class="headerlink" title="三 System.arraycopy() 和 Arrays.copyOf()方法"></a>三 <code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</h2><p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p><h3 id="3-1-System-arraycopy-方法"><a href="#3-1-System-arraycopy-方法" class="headerlink" title="3.1 System.arraycopy() 方法"></a>3.1 <code>System.arraycopy()</code> 方法</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 在此列表中的指定位置插入指定的元素。 </span><span class="hljs-comment"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span><span class="hljs-comment"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;    rangeCheckForAdd(index);    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>    <span class="hljs-comment">//arraycopy()方法实现数组自己复制自己</span>    <span class="hljs-comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span>    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>, size - index);    elementData[index] = element;    size++;&#125;</code></pre><p>我们写一个简单的方法测试以下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArraycopyTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span><span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;a[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;a[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;a[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;System.arraycopy(a, <span class="hljs-number">2</span>, a, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>);a[<span class="hljs-number">2</span>]=<span class="hljs-number">99</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;System.out.print(a[i] + <span class="hljs-string">&quot; &quot;</span>);&#125;&#125;&#125;</code></pre><p>结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">99</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span></code></pre><h3 id="3-2-Arrays-copyOf-方法"><a href="#3-2-Arrays-copyOf-方法" class="headerlink" title="3.2 Arrays.copyOf()方法"></a>3.2 <code>Arrays.copyOf()</code>方法</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 </span><span class="hljs-comment">  */</span> <span class="hljs-keyword">public</span> Object[] toArray() &#123; <span class="hljs-comment">//elementData：要复制的数组；size：要复制的长度</span>     <span class="hljs-keyword">return</span> Arrays.copyOf(elementData, size); &#125;</code></pre><p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayscopyOfTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;a[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;a[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<span class="hljs-keyword">int</span>[] b = Arrays.copyOf(a, <span class="hljs-number">10</span>);System.out.println(<span class="hljs-string">&quot;b.length&quot;</span>+b.length);&#125;&#125;</code></pre><p>结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">10</span></code></pre><h3 id="3-3-两者联系和区别"><a href="#3-3-两者联系和区别" class="headerlink" title="3.3 两者联系和区别"></a>3.3 两者联系和区别</h3><p><strong>联系：</strong></p><p>看两者源代码可以发现 copyOf() 内部实际调用了 <code>System.arraycopy()</code> 方法</p><p><strong>区别：</strong></p><p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p><h2 id="四-ensureCapacity方法"><a href="#四-ensureCapacity方法" class="headerlink" title="四 ensureCapacity方法"></a>四 <code>ensureCapacity</code>方法</h2><p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>   minCapacity   所需的最小容量</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)        <span class="hljs-comment">// any size if not default element table</span>        ? <span class="hljs-number">0</span>        <span class="hljs-comment">// larger than default for default empty table. It&#x27;s already</span>        <span class="hljs-comment">// supposed to be at default size.</span>        : DEFAULT_CAPACITY;    <span class="hljs-keyword">if</span> (minCapacity &gt; minExpand) &#123;        ensureExplicitCapacity(minCapacity);    &#125;&#125;</code></pre><p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</strong></p><p>我们通过下面的代码实际测试以下这个方法的效果：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnsureCapacityTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ArrayList&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10000000</span>;<span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;list.add(i);&#125;<span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();System.out.println(<span class="hljs-string">&quot;使用ensureCapacity方法前：&quot;</span>+(endTime - startTime));&#125;&#125;</code></pre><p>运行结果：</p><pre><code class="hljs java">使用ensureCapacity方法前：<span class="hljs-number">2158</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnsureCapacityTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ArrayList&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10000000</span>;        list = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();        <span class="hljs-keyword">long</span> startTime1 = System.currentTimeMillis();        list.ensureCapacity(N);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;            list.add(i);        &#125;        <span class="hljs-keyword">long</span> endTime1 = System.currentTimeMillis();        System.out.println(<span class="hljs-string">&quot;使用ensureCapacity方法后：&quot;</span>+(endTime1 - startTime1));    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="hljs angelscript">使用ensureCapacity方法前：<span class="hljs-number">1773</span></code></pre><p>通过运行结果，我们可以看出向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ArrayList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Collections 工具类和 Arrays 工具类常见方法</title>
    <link href="/2020/09/04/Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%92%8C-Arrays-%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/"/>
    <url>/2020/09/04/Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%92%8C-Arrays-%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="转自JavaGuide：https-gitee-com-SnailClimb-JavaGuide-blob-master-docs-java-basic-Arrays-CollectionsCommonMethods-md"><a href="#转自JavaGuide：https-gitee-com-SnailClimb-JavaGuide-blob-master-docs-java-basic-Arrays-CollectionsCommonMethods-md" class="headerlink" title="转自JavaGuide：https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md"></a>转自JavaGuide：<a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md">https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md</a></h3><!-- TOC --><ul><li><a href="#collections-%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%92%8C-arrays-%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95">Collections 工具类和 Arrays 工具类常见方法</a><ul><li><a href="#collections">Collections</a><ul><li><a href="#%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C">排序操作</a></li><li><a href="#%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2%E6%93%8D%E4%BD%9C">查找,替换操作</a></li><li><a href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6">同步控制</a></li></ul></li><li><a href="#arrays%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C">Arrays类的常见操作</a><ul><li><a href="#%E6%8E%92%E5%BA%8F--sort">排序 : <code>sort()</code></a></li><li><a href="#%E6%9F%A5%E6%89%BE--binarysearch">查找 : <code>binarySearch()</code></a></li><li><a href="#%E6%AF%94%E8%BE%83-equals">比较: <code>equals()</code></a></li><li><a href="#%E5%A1%AB%E5%85%85--fill">填充 : <code>fill()</code></a></li><li><a href="#%E8%BD%AC%E5%88%97%E8%A1%A8-aslist">转列表 <code>asList()</code></a></li><li><a href="#%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-tostring">转字符串 <code>toString()</code></a></li><li><a href="#%E5%A4%8D%E5%88%B6-copyof">复制 <code>copyOf()</code></a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="Collections-工具类和-Arrays-工具类常见方法"><a href="#Collections-工具类和-Arrays-工具类常见方法" class="headerlink" title="Collections 工具类和 Arrays 工具类常见方法"></a>Collections 工具类和 Arrays 工具类常见方法</h1><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>Collections 工具类常用方法:</p><ol><li>排序</li><li>查找,替换操作</li><li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li></ol><h3 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(List list)</span><span class="hljs-comment">//反转</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shuffle</span><span class="hljs-params">(List list)</span><span class="hljs-comment">//随机排序</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(List list)</span><span class="hljs-comment">//按自然排序的升序排序</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(List list, Comparator c)</span><span class="hljs-comment">//定制排序，由Comparator控制排序逻辑</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(List list, <span class="hljs-keyword">int</span> i , <span class="hljs-keyword">int</span> j)</span><span class="hljs-comment">//交换两个索引位置的元素</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(List list, <span class="hljs-keyword">int</span> distance)</span><span class="hljs-comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。</span></span></code></pre><p><strong>示例代码:</strong></p><pre><code class="hljs java">   ArrayList&lt;Integer&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();arrayList.add(-<span class="hljs-number">1</span>);arrayList.add(<span class="hljs-number">3</span>);arrayList.add(<span class="hljs-number">3</span>);arrayList.add(-<span class="hljs-number">5</span>);arrayList.add(<span class="hljs-number">7</span>);arrayList.add(<span class="hljs-number">4</span>);arrayList.add(-<span class="hljs-number">9</span>);arrayList.add(-<span class="hljs-number">7</span>);System.out.println(<span class="hljs-string">&quot;原始数组:&quot;</span>);System.out.println(arrayList);<span class="hljs-comment">// void reverse(List list)：反转</span>Collections.reverse(arrayList);System.out.println(<span class="hljs-string">&quot;Collections.reverse(arrayList):&quot;</span>);System.out.println(arrayList);Collections.rotate(arrayList, <span class="hljs-number">4</span>);System.out.println(<span class="hljs-string">&quot;Collections.rotate(arrayList, 4):&quot;</span>);System.out.println(arrayList);<span class="hljs-comment">// void sort(List list),按自然排序的升序排序</span>Collections.sort(arrayList);System.out.println(<span class="hljs-string">&quot;Collections.sort(arrayList):&quot;</span>);System.out.println(arrayList);<span class="hljs-comment">// void shuffle(List list),随机排序</span>Collections.shuffle(arrayList);System.out.println(<span class="hljs-string">&quot;Collections.shuffle(arrayList):&quot;</span>);System.out.println(arrayList);<span class="hljs-comment">// void swap(List list, int i , int j),交换两个索引位置的元素</span>Collections.swap(arrayList, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>);System.out.println(<span class="hljs-string">&quot;Collections.swap(arrayList, 2, 5):&quot;</span>);System.out.println(arrayList);<span class="hljs-comment">// 定制排序的用法</span>Collections.sort(arrayList, <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<span class="hljs-keyword">return</span> o2.compareTo(o1);&#125;&#125;);System.out.println(<span class="hljs-string">&quot;定制排序后：&quot;</span>);System.out.println(arrayList);</code></pre><h3 id="查找-替换操作"><a href="#查找-替换操作" class="headerlink" title="查找,替换操作"></a>查找,替换操作</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(List list, Object key)</span><span class="hljs-comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(Collection coll)</span><span class="hljs-comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(Collection coll, Comparator c)</span><span class="hljs-comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fill</span><span class="hljs-params">(List list, Object obj)</span><span class="hljs-comment">//用指定的元素代替指定list中的所有元素。</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">frequency</span><span class="hljs-params">(Collection c, Object o)</span><span class="hljs-comment">//统计元素出现次数</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">indexOfSubList</span><span class="hljs-params">(List list, List target)</span><span class="hljs-comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).</span></span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">replaceAll</span><span class="hljs-params">(List list, Object oldVal, Object newVal)</span>, 用新元素替换旧元素</span></code></pre><p><strong>示例代码：</strong></p><pre><code class="hljs java">ArrayList&lt;Integer&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();arrayList.add(-<span class="hljs-number">1</span>);arrayList.add(<span class="hljs-number">3</span>);arrayList.add(<span class="hljs-number">3</span>);arrayList.add(-<span class="hljs-number">5</span>);arrayList.add(<span class="hljs-number">7</span>);arrayList.add(<span class="hljs-number">4</span>);arrayList.add(-<span class="hljs-number">9</span>);arrayList.add(-<span class="hljs-number">7</span>);ArrayList&lt;Integer&gt; arrayList2 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();arrayList2.add(-<span class="hljs-number">3</span>);arrayList2.add(-<span class="hljs-number">5</span>);arrayList2.add(<span class="hljs-number">7</span>);System.out.println(<span class="hljs-string">&quot;原始数组:&quot;</span>);System.out.println(arrayList);System.out.println(<span class="hljs-string">&quot;Collections.max(arrayList):&quot;</span>);System.out.println(Collections.max(arrayList));System.out.println(<span class="hljs-string">&quot;Collections.min(arrayList):&quot;</span>);System.out.println(Collections.min(arrayList));System.out.println(<span class="hljs-string">&quot;Collections.replaceAll(arrayList, 3, -3):&quot;</span>);Collections.replaceAll(arrayList, <span class="hljs-number">3</span>, -<span class="hljs-number">3</span>);System.out.println(arrayList);System.out.println(<span class="hljs-string">&quot;Collections.frequency(arrayList, -3):&quot;</span>);System.out.println(Collections.frequency(arrayList, -<span class="hljs-number">3</span>));System.out.println(<span class="hljs-string">&quot;Collections.indexOfSubList(arrayList, arrayList2):&quot;</span>);System.out.println(Collections.indexOfSubList(arrayList, arrayList2));System.out.println(<span class="hljs-string">&quot;Collections.binarySearch(arrayList, 7):&quot;</span>);<span class="hljs-comment">// 对List进行二分查找，返回索引，List必须是有序的</span>Collections.sort(arrayList);System.out.println(Collections.binarySearch(arrayList, <span class="hljs-number">7</span>));</code></pre><h3 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h3><p>Collections提供了多个<code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p><p>我们知道 HashSet，TreeSet，ArrayList,LinkedList,HashMap,TreeMap 都是线程不安全的。Collections提供了多个静态方法可以把他们包装成线程同步的集合。</p><p><strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。</strong></p><p>方法如下：</p><pre><code class="hljs java">synchronizedCollection(Collection&lt;T&gt;  c) <span class="hljs-comment">//返回指定 collection 支持的同步（线程安全的）collection。</span>synchronizedList(List&lt;T&gt; list)<span class="hljs-comment">//返回指定列表支持的同步（线程安全的）List。</span>synchronizedMap(Map&lt;K,V&gt; m) <span class="hljs-comment">//返回由指定映射支持的同步（线程安全的）Map。</span>synchronizedSet(Set&lt;T&gt; s) <span class="hljs-comment">//返回指定 set 支持的同步（线程安全的）set。</span></code></pre><h3 id="Collections还可以设置不可变集合，提供了如下三类方法："><a href="#Collections还可以设置不可变集合，提供了如下三类方法：" class="headerlink" title="Collections还可以设置不可变集合，提供了如下三类方法："></a>Collections还可以设置不可变集合，提供了如下三类方法：</h3><pre><code class="hljs java">emptyXxx(): 返回一个空的、不可变的集合对象，此处的集合既可以是List，也可以是Set，还可以是Map。singletonXxx(): 返回一个只包含指定对象（只有一个或一个元素）的不可变的集合对象，此处的集合可以是：List，Set，Map。unmodifiableXxx(): 返回指定集合对象的不可变视图，此处的集合可以是：List，Set，Map。上面三类方法的参数是原有的集合对象，返回值是该集合的”只读“版本。</code></pre><p><strong>示例代码：</strong></p><pre><code class="hljs java">        ArrayList&lt;Integer&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();        arrayList.add(-<span class="hljs-number">1</span>);        arrayList.add(<span class="hljs-number">3</span>);        arrayList.add(<span class="hljs-number">3</span>);        arrayList.add(-<span class="hljs-number">5</span>);        arrayList.add(<span class="hljs-number">7</span>);        arrayList.add(<span class="hljs-number">4</span>);        arrayList.add(-<span class="hljs-number">9</span>);        arrayList.add(-<span class="hljs-number">7</span>);        HashSet&lt;Integer&gt; integers1 = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        integers1.add(<span class="hljs-number">1</span>);        integers1.add(<span class="hljs-number">3</span>);        integers1.add(<span class="hljs-number">2</span>);        Map scores = <span class="hljs-keyword">new</span> HashMap();        scores.put(<span class="hljs-string">&quot;语文&quot;</span> , <span class="hljs-number">80</span>);        scores.put(<span class="hljs-string">&quot;Java&quot;</span> , <span class="hljs-number">82</span>);        <span class="hljs-comment">//Collections.emptyXXX();创建一个空的、不可改变的XXX对象</span>        List&lt;Object&gt; list = Collections.emptyList();        System.out.println(list);<span class="hljs-comment">//[]</span>        Set&lt;Object&gt; objects = Collections.emptySet();        System.out.println(objects);<span class="hljs-comment">//[]</span>        Map&lt;Object, Object&gt; objectObjectMap = Collections.emptyMap();        System.out.println(objectObjectMap);<span class="hljs-comment">//&#123;&#125;</span>        <span class="hljs-comment">//Collections.singletonXXX();</span>        List&lt;ArrayList&lt;Integer&gt;&gt; arrayLists = Collections.singletonList(arrayList);        System.out.println(arrayLists);<span class="hljs-comment">//[[-1, 3, 3, -5, 7, 4, -9, -7]]</span>        <span class="hljs-comment">//创建一个只有一个元素，且不可改变的Set对象</span>        Set&lt;ArrayList&lt;Integer&gt;&gt; singleton = Collections.singleton(arrayList);        System.out.println(singleton);<span class="hljs-comment">//[[-1, 3, 3, -5, 7, 4, -9, -7]]</span>        Map&lt;String, String&gt; nihao = Collections.singletonMap(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;nihao&quot;</span>);        System.out.println(nihao);<span class="hljs-comment">//&#123;1=nihao&#125;</span>        <span class="hljs-comment">//unmodifiableXXX();创建普通XXX对象对应的不可变版本</span>        List&lt;Integer&gt; integers = Collections.unmodifiableList(arrayList);        System.out.println(integers);<span class="hljs-comment">//[-1, 3, 3, -5, 7, 4, -9, -7]</span>        Set&lt;Integer&gt; integers2 = Collections.unmodifiableSet(integers1);        System.out.println(integers2);<span class="hljs-comment">//[1, 2, 3]</span>        Map&lt;Object, Object&gt; objectObjectMap2 = Collections.unmodifiableMap(scores);        System.out.println(objectObjectMap2);<span class="hljs-comment">//&#123;Java=82, 语文=80&#125;</span>        <span class="hljs-comment">//添加出现异常：java.lang.UnsupportedOperationException</span><span class="hljs-comment">//        list.add(1);</span><span class="hljs-comment">//        arrayLists.add(arrayList);</span><span class="hljs-comment">//        integers.add(1);</span></code></pre><h2 id="Arrays类的常见操作"><a href="#Arrays类的常见操作" class="headerlink" title="Arrays类的常见操作"></a>Arrays类的常见操作</h2><ol><li>排序 : <code>sort()</code></li><li>查找 : <code>binarySearch()</code></li><li>比较: <code>equals()</code></li><li>填充 : <code>fill()</code></li><li>转列表:  <code>asList()</code></li><li>转字符串 : <code>toString()</code></li><li>复制: <code>copyOf()</code></li></ol><h3 id="排序-sort"><a href="#排序-sort" class="headerlink" title="排序 : sort()"></a>排序 : <code>sort()</code></h3><pre><code class="hljs java"><span class="hljs-comment">// *************排序 sort****************</span><span class="hljs-keyword">int</span> a[] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span> &#125;;<span class="hljs-comment">// sort(int[] a)方法按照数字顺序排列指定的数组。</span>Arrays.sort(a);System.out.println(<span class="hljs-string">&quot;Arrays.sort(a):&quot;</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : a) &#123;System.out.print(i);&#125;<span class="hljs-comment">// 换行</span>System.out.println();<span class="hljs-comment">// sort(int[] a,int fromIndex,int toIndex)按升序排列数组的指定范围</span><span class="hljs-keyword">int</span> b[] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span> &#125;;Arrays.sort(b, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>);System.out.println(<span class="hljs-string">&quot;Arrays.sort(b, 2, 6):&quot;</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : b) &#123;System.out.print(i);&#125;<span class="hljs-comment">// 换行</span>System.out.println();<span class="hljs-keyword">int</span> c[] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span> &#125;;<span class="hljs-comment">// parallelSort(int[] a) 按照数字顺序排列指定的数组(并行的)。同sort方法一样也有按范围的排序</span>Arrays.parallelSort(c);System.out.println(<span class="hljs-string">&quot;Arrays.parallelSort(c)：&quot;</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : c) &#123;System.out.print(i);&#125;<span class="hljs-comment">// 换行</span>System.out.println();<span class="hljs-comment">// parallelSort给字符数组排序，sort也可以</span><span class="hljs-keyword">char</span> d[] = &#123; <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span> &#125;;Arrays.parallelSort(d);System.out.println(<span class="hljs-string">&quot;Arrays.parallelSort(d)：&quot;</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> d2 : d) &#123;System.out.print(d2);&#125;<span class="hljs-comment">// 换行</span>System.out.println();</code></pre><p>在做算法面试题的时候，我们还可能会经常遇到对字符串排序的情况,<code>Arrays.sort()</code> 对每个字符串的特定位置进行比较，然后按照升序排序。</p><pre><code class="hljs java">String[] strs = &#123; <span class="hljs-string">&quot;abcdehg&quot;</span>, <span class="hljs-string">&quot;abcdefg&quot;</span>, <span class="hljs-string">&quot;abcdeag&quot;</span> &#125;;Arrays.sort(strs);System.out.println(Arrays.toString(strs));<span class="hljs-comment">//[abcdeag, abcdefg, abcdehg]</span></code></pre><h3 id="查找-binarySearch"><a href="#查找-binarySearch" class="headerlink" title="查找 : binarySearch()"></a>查找 : <code>binarySearch()</code></h3><pre><code class="hljs java"><span class="hljs-comment">// *************查找 binarySearch()****************</span><span class="hljs-keyword">char</span>[] e = &#123; <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span> &#125;;<span class="hljs-comment">// 排序后再进行二分查找，否则找不到</span>Arrays.sort(e);System.out.println(<span class="hljs-string">&quot;Arrays.sort(e)&quot;</span> + Arrays.toString(e));System.out.println(<span class="hljs-string">&quot;Arrays.binarySearch(e, &#x27;c&#x27;)：&quot;</span>);<span class="hljs-keyword">int</span> s = Arrays.binarySearch(e, <span class="hljs-string">&#x27;c&#x27;</span>);System.out.println(<span class="hljs-string">&quot;字符c在数组的位置：&quot;</span> + s);</code></pre><h3 id="比较-equals"><a href="#比较-equals" class="headerlink" title="比较: equals()"></a>比较: <code>equals()</code></h3><pre><code class="hljs java"><span class="hljs-comment">// *************比较 equals****************</span><span class="hljs-keyword">char</span>[] e = &#123; <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span> &#125;;<span class="hljs-keyword">char</span>[] f = &#123; <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span> &#125;;<span class="hljs-comment">/*</span><span class="hljs-comment">* 元素数量相同，并且相同位置的元素相同。 另外，如果两个数组引用都是null，则它们被认为是相等的 。</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 输出true</span>System.out.println(<span class="hljs-string">&quot;Arrays.equals(e, f):&quot;</span> + Arrays.equals(e, f));</code></pre><h3 id="填充-fill"><a href="#填充-fill" class="headerlink" title="填充 : fill()"></a>填充 : <code>fill()</code></h3><pre><code class="hljs java"><span class="hljs-comment">// *************填充fill(批量初始化)****************</span><span class="hljs-keyword">int</span>[] g = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span> &#125;;<span class="hljs-comment">// 数组中所有元素重新分配值</span>Arrays.fill(g, <span class="hljs-number">3</span>);System.out.println(<span class="hljs-string">&quot;Arrays.fill(g, 3)：&quot;</span>);<span class="hljs-comment">// 输出结果：333333333</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : g) &#123;System.out.print(i);&#125;<span class="hljs-comment">// 换行</span>System.out.println();<span class="hljs-keyword">int</span>[] h = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, &#125;;<span class="hljs-comment">// 数组中指定范围元素重新分配值</span>Arrays.fill(h, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>);System.out.println(<span class="hljs-string">&quot;Arrays.fill(h, 0, 2, 9);：&quot;</span>);<span class="hljs-comment">// 输出结果：993333666</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : h) &#123;System.out.print(i);&#125;</code></pre><h3 id="转列表-asList"><a href="#转列表-asList" class="headerlink" title="转列表 asList()"></a>转列表 <code>asList()</code></h3><pre><code class="hljs java"><span class="hljs-comment">// *************转列表 asList()****************</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * 返回由指定数组支持的固定大小的列表。</span><span class="hljs-comment"> * （将返回的列表更改为“写入数组”。）该方法作为基于数组和基于集合的API之间的桥梁，与Collection.toArray()相结合 。</span><span class="hljs-comment"> * 返回的列表是可序列化的，并实现RandomAccess 。</span><span class="hljs-comment"> * 此方法还提供了一种方便的方式来创建一个初始化为包含几个元素的固定大小的列表如下：</span><span class="hljs-comment"> */</span>List&lt;String&gt; stooges = Arrays.asList(<span class="hljs-string">&quot;Larry&quot;</span>, <span class="hljs-string">&quot;Moe&quot;</span>, <span class="hljs-string">&quot;Curly&quot;</span>);System.out.println(stooges);</code></pre><h3 id="转字符串-toString"><a href="#转字符串-toString" class="headerlink" title="转字符串 toString()"></a>转字符串 <code>toString()</code></h3><pre><code class="hljs java"><span class="hljs-comment">// *************转字符串 toString()****************</span><span class="hljs-comment">/*</span><span class="hljs-comment">* 返回指定数组的内容的字符串表示形式。</span><span class="hljs-comment">*/</span><span class="hljs-keyword">char</span>[] k = &#123; <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span> &#125;;System.out.println(Arrays.toString(k));<span class="hljs-comment">// [a, f, b, c, e, A, C, B]</span></code></pre><h3 id="复制-copyOf"><a href="#复制-copyOf" class="headerlink" title="复制 copyOf()"></a>复制 <code>copyOf()</code></h3><pre><code class="hljs java"><span class="hljs-comment">// *************复制 copy****************</span><span class="hljs-comment">// copyOf 方法实现数组复制,h为数组，6为复制的长度</span><span class="hljs-keyword">int</span>[] h = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, &#125;;<span class="hljs-keyword">int</span> i[] = Arrays.copyOf(h, <span class="hljs-number">6</span>);System.out.println(<span class="hljs-string">&quot;Arrays.copyOf(h, 6);：&quot;</span>);<span class="hljs-comment">// 输出结果：123333</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j : i) &#123;System.out.print(j);&#125;<span class="hljs-comment">// 换行</span>System.out.println();<span class="hljs-comment">// copyOfRange将指定数组的指定范围复制到新数组中</span><span class="hljs-keyword">int</span> j[] = Arrays.copyOfRange(h, <span class="hljs-number">6</span>, <span class="hljs-number">11</span>);System.out.println(<span class="hljs-string">&quot;Arrays.copyOfRange(h, 6, 11)：&quot;</span>);<span class="hljs-comment">// 输出结果66600(h数组只有9个元素这里是从索引6到索引11复制所以不足的就为0)</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j2 : j) &#123;System.out.print(j2);&#125;<span class="hljs-comment">// 换行</span>System.out.println();</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Java知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java关键字总结</title>
    <link href="/2020/09/04/Java%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/"/>
    <url>/2020/09/04/Java%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="转自javaGuide：https-gitee-com-SnailClimb-JavaGuide-blob-master-docs-java-basic-Arrays-CollectionsCommonMethods-md"><a href="#转自javaGuide：https-gitee-com-SnailClimb-JavaGuide-blob-master-docs-java-basic-Arrays-CollectionsCommonMethods-md" class="headerlink" title="转自javaGuide：https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md"></a>转自javaGuide：<a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md">https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md</a></h3><!-- MarkdownTOC --><ul><li><a href="#finalstaticthissuper-%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93">final,static,this,super 关键字总结</a><ul><li><a href="#final-%E5%85%B3%E9%94%AE%E5%AD%97">final 关键字</a></li><li><a href="#static-%E5%85%B3%E9%94%AE%E5%AD%97">static 关键字</a></li><li><a href="#this-%E5%85%B3%E9%94%AE%E5%AD%97">this 关键字</a></li><li><a href="#super-%E5%85%B3%E9%94%AE%E5%AD%97">super 关键字</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul></li><li><a href="#static-%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3">static 关键字详解</a><ul><li><a href="#static-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%BB%E8%A6%81%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%9B%9B%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">static 关键字主要有以下四种使用场景</a><ul><li><a href="#%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E5%B8%B8%E7%94%A8">修饰成员变量和成员方法(常用)</a></li><li><a href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97">静态代码块</a></li><li><a href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB">静态内部类</a></li><li><a href="#%E9%9D%99%E6%80%81%E5%AF%BC%E5%8C%85">静态导包</a></li></ul></li><li><a href="#%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9">补充内容</a><ul><li><a href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">静态方法与非静态方法</a></li><li><a href="#static%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97">static{}静态代码块与{}非静态代码块(构造代码块)</a></li><li><a href="#%E5%8F%82%E8%80%83-1">参考</a></li></ul></li></ul></li></ul><!-- /MarkdownTOC --><h1 id="final-static-this-super-关键字总结"><a href="#final-static-this-super-关键字总结" class="headerlink" title="final,static,this,super 关键字总结"></a>final,static,this,super 关键字总结</h1><h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><p><strong>final关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点：</strong></p><ol><li><p><strong>final修饰的类不能被继承，final类中的所有成员方法都会被隐式的指定为final方法；</strong></p></li><li><p><strong>final修饰的方法不能被重写；</strong></p></li><li><p><strong>final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。</strong></p></li></ol><p>说明：使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。</p><h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><p><strong>static 关键字主要有以下四种使用场景：</strong></p><ol><li><strong>修饰成员变量和成员方法:</strong> 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：<code>类名.静态变量名</code>    <code>类名.静态方法名()</code></li><li><strong>静态代码块:</strong> 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li><li><strong>静态内部类（static修饰类的话只能修饰内部类）：</strong> 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。</li><li><strong>静态导包(用来导入类中的静态资源，1.5之后的新特性):</strong> 格式为：<code>import static</code> 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li></ol><h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p>this关键字用于引用类的当前实例。 例如：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> </span>&#123;    Employees[] employees;         <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">manageEmployees</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> totalEmp = <span class="hljs-keyword">this</span>.employees.length;        System.out.println(<span class="hljs-string">&quot;Total employees: &quot;</span> + totalEmp);        <span class="hljs-keyword">this</span>.report();    &#125;         <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">report</span><span class="hljs-params">()</span> </span>&#123; &#125;&#125;</code></pre><p>在上面的示例中，this关键字用于两个地方：</p><ul><li>this.employees.length：访问类Manager的当前实例的变量。</li><li>this.report（）：调用类Manager的当前实例的方法。</li></ul><p>此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。</p><h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>super关键字用于从子类访问父类的变量和方法。 例如：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Super</span> </span>&#123;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> number;         <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">showNumber</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;number = &quot;</span> + number);    &#125;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Super</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.number = <span class="hljs-number">10</span>;        <span class="hljs-keyword">super</span>.showNumber();    &#125;&#125;</code></pre><p>在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 <code>showNumber（）</code> 方法。</p><p><strong>使用 this 和 super 要注意的问题：</strong></p><ul><li>在构造器中使用 <code>super（）</code> 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。</li><li>this、super不能用在static方法中。</li></ul><p><strong>简单解释一下：</strong></p><p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， <strong>this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西</strong>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.codejava.net/java-core/the-java-language/java-keywords">https://www.codejava.net/java-core/the-java-language/java-keywords</a></li><li><a href="https://blog.csdn.net/u013393958/article/details/79881037">https://blog.csdn.net/u013393958/article/details/79881037</a></li></ul><h1 id="static-关键字详解"><a href="#static-关键字详解" class="headerlink" title="static 关键字详解"></a>static 关键字详解</h1><h2 id="static-关键字主要有以下四种使用场景"><a href="#static-关键字主要有以下四种使用场景" class="headerlink" title="static 关键字主要有以下四种使用场景"></a>static 关键字主要有以下四种使用场景</h2><ol><li>修饰成员变量和成员方法</li><li>静态代码块</li><li>修饰类(只能修饰内部类)</li><li>静态导包(用来导入类中的静态资源，1.5之后的新特性)</li></ol><h3 id="修饰成员变量和成员方法-常用"><a href="#修饰成员变量和成员方法-常用" class="headerlink" title="修饰成员变量和成员方法(常用)"></a>修饰成员变量和成员方法(常用)</h3><p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。</p><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p><p> HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。</p><p>调用格式：</p><ul><li><code>类名.静态变量名</code></li><li><code>类名.静态方法名()</code></li></ul><p>如果变量或者方法被 private 则代表该属性或者该方法只能在类的内部被访问而不能在类的外部被访问。</p><p>测试方法：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticBean</span> </span>&#123;    String name;    <span class="hljs-comment">//静态变量</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StaticBean</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-comment">//静态方法</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SayHello</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Hello i am java&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;StaticBean&#123;&quot;</span>+                <span class="hljs-string">&quot;name=&quot;</span> + name + <span class="hljs-string">&quot;,age=&quot;</span> + age +                <span class="hljs-string">&quot;&#125;&quot;</span>;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        StaticBean staticBean = <span class="hljs-keyword">new</span> StaticBean(<span class="hljs-string">&quot;1&quot;</span>);        StaticBean staticBean2 = <span class="hljs-keyword">new</span> StaticBean(<span class="hljs-string">&quot;2&quot;</span>);        StaticBean staticBean3 = <span class="hljs-keyword">new</span> StaticBean(<span class="hljs-string">&quot;3&quot;</span>);        StaticBean staticBean4 = <span class="hljs-keyword">new</span> StaticBean(<span class="hljs-string">&quot;4&quot;</span>);        StaticBean.age = <span class="hljs-number">33</span>;        System.out.println(staticBean + <span class="hljs-string">&quot; &quot;</span> + staticBean2 + <span class="hljs-string">&quot; &quot;</span> + staticBean3 + <span class="hljs-string">&quot; &quot;</span> + staticBean4);        <span class="hljs-comment">//StaticBean&#123;name=1,age=33&#125; StaticBean&#123;name=2,age=33&#125; StaticBean&#123;name=3,age=33&#125; StaticBean&#123;name=4,age=33&#125;</span>        StaticBean.SayHello();<span class="hljs-comment">//Hello i am java</span>    &#125;&#125;</code></pre><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</p><p>静态代码块的格式是 </p><pre><code class="hljs abnf">static &#123;    语句体<span class="hljs-comment">;   </span>&#125;</code></pre><p>一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-14/88531075.jpg"></p><p>静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问.</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：</p><ol><li>它的创建是不需要依赖外围类的创建。</li><li>它不能使用任何外围类的非static成员变量和方法。</li></ol><p>Example（静态内部类实现单例模式）</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;        <span class="hljs-comment">//声明为 private 避免调用默认构造方法创建对象</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;    &#125;       <span class="hljs-comment">// 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;    &#125;&#125;</code></pre><p>当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance() </code>方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。</p><p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p><h3 id="静态导包"><a href="#静态导包" class="headerlink" title="静态导包"></a>静态导包</h3><p>格式为：import static </p><p>这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法</p><pre><code class="hljs java"> <span class="hljs-comment">//将Math中的所有静态资源导入，这时候可以直接使用里面的静态方法，而不用通过类名进行调用</span> <span class="hljs-comment">//如果只想导入单一某个静态方法，只需要将换成对应的方法名即可</span> <span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.*;<span class="hljs-comment">//换成import static java.lang.Math.max;具有一样的效果</span> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;     <span class="hljs-keyword">int</span> max = max(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);    System.out.println(max);  &#125;&#125;</code></pre><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><h3 id="静态方法与非静态方法"><a href="#静态方法与非静态方法" class="headerlink" title="静态方法与非静态方法"></a>静态方法与非静态方法</h3><p>静态方法属于类本身，非静态方法属于从该类生成的每个对象。 如果您的方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。</p><p>Example</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">this</span>.i = i;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;An example string that doesn&#x27;t depend on i (an instance variable)&quot;</span>;           &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.i + <span class="hljs-number">1</span>;  <span class="hljs-comment">//Depends on i</span>    &#125;&#125;</code></pre><p>你可以像这样调用静态方法：<code>Foo.method1()</code>。 如果您尝试使用这种方法调用 method2 将失败。 但这样可行：<code>Foo bar = new Foo(1);bar.method2();</code></p><p>总结：</p><ul><li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 </li><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制 </li></ul><h3 id="static-静态代码块与-非静态代码块-构造代码块"><a href="#static-静态代码块与-非静态代码块-构造代码块" class="headerlink" title="static{}静态代码块与{}非静态代码块(构造代码块)"></a><code>static&#123;&#125;</code>静态代码块与<code>&#123;&#125;</code>非静态代码块(构造代码块)</h3><p>相同点： 都是在JVM加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些static变量进行赋值。 </p><p>不同点： 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。 </p><blockquote><p>修正 <a href="https://github.com/Snailclimb/JavaGuide/issues/677">issue #677</a>：静态代码块可能在第一次new的时候执行，但不一定只在第一次new的时候执行。比如通过 <code>Class.forName(&quot;ClassDemo&quot;)</code>创建 Class 对象的时候也会执行。</p></blockquote><p>一般情况下,如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的。如果我们想要设计不需要创建对象就可以调用类中的方法，例如：Arrays类，Character类，String类等，就需要使用静态方法, 两者的区别是 静态代码块是自动执行的而静态方法是被调用的时候才执行的. </p><p>Example：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> </span>&#123;        System.out.print(<span class="hljs-string">&quot;默认构造方法！--&quot;</span>);    &#125;    <span class="hljs-comment">//非静态代码块</span>    &#123;        System.out.print(<span class="hljs-string">&quot;非静态代码块！--&quot;</span>);    &#125;    <span class="hljs-comment">//静态代码块</span>    <span class="hljs-keyword">static</span> &#123;        System.out.print(<span class="hljs-string">&quot;静态代码块！--&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        System.out.print(<span class="hljs-string">&quot;静态方法中的内容! --&quot;</span>);        &#123;            System.out.print(<span class="hljs-string">&quot;静态方法中的代码块！--&quot;</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Test test = <span class="hljs-keyword">new</span> Test();        Test.test();<span class="hljs-comment">//静态代码块！--静态方法中的内容! --静态方法中的代码块！--</span>    &#125;&#125;</code></pre><p>上述代码输出：</p><pre><code class="hljs brainfuck"><span class="hljs-comment">静态代码块！</span>--<span class="hljs-comment">非静态代码块！</span>--<span class="hljs-comment">默认构造方法！</span>--<span class="hljs-comment">静态方法中的内容!</span> --<span class="hljs-comment">静态方法中的代码块！</span>--</code></pre><p>当只执行 <code>Test.test();</code> 时输出：</p><pre><code class="hljs brainfuck"><span class="hljs-comment">静态代码块！</span>--<span class="hljs-comment">静态方法中的内容!</span> --<span class="hljs-comment">静态方法中的代码块！</span>--</code></pre><p>当只执行 <code>Test test = new Test();</code> 时输出：</p><pre><code class="hljs brainfuck"><span class="hljs-comment">静态代码块！</span>--<span class="hljs-comment">非静态代码块！</span>--<span class="hljs-comment">默认构造方法！</span>--</code></pre><p>非静态代码块与构造函数的区别是： 非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。 </p><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul><li>httpsblog.csdn.netchen13579867831articledetails78995480</li><li>http<a href="http://www.cnblogs.comchenssyp3388487.html/">www.cnblogs.comchenssyp3388487.html</a></li><li>http<a href="http://www.cnblogs.comqian123p5713440.html/">www.cnblogs.comQian123p5713440.html</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo开发问题总结</title>
    <link href="/2020/09/02/hexo%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2020/09/02/hexo%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo插入图片无法显示-目录前多-com"><a href="#hexo插入图片无法显示-目录前多-com" class="headerlink" title="hexo插入图片无法显示 目录前多.com"></a>hexo插入图片无法显示 目录前多.com</h1><p>解决方案</p><pre><code class="hljs autohotkey"><span class="hljs-number">1</span>. 将博客根目录下的文件 `_config.yml` 中的 `post_asset_folder: <span class="hljs-literal">false</span>` 改为 `post_asset_folder: <span class="hljs-literal">true</span>`。<span class="hljs-number">2</span>. cmd 在博客根目录下 `npm install hexo-asset-image -–save`。<span class="hljs-number">3</span>. 将博客根目录下的文件 `package.json` 中的 `&quot;hexo-asset-image<span class="hljs-string">&quot;: &quot;</span><span class="hljs-number">1.0</span>.<span class="hljs-number">0</span><span class="hljs-string">&quot;` 修改为 `&quot;hexo-asset-image&quot;</span>: <span class="hljs-string">&quot;0.0.3&quot;</span>`，在博客根目录下 cmd `npm install`；<span class="hljs-number">4</span>. 修改 `博客根目录\node_modules\hexo-asset-image\index.js` 文件中的第 <span class="hljs-number">38</span> 行为 `var srcArray = decodeURI(src).split(&#x27;/&#x27;).filter(function(elem)&#123;`；<span class="hljs-number">5</span>. 在博客根目录下 cmd `hexo clean &amp;&amp; hexo g &amp;&amp; hexo s`，完成。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>问题总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swagger-UI问题总结</title>
    <link href="/2020/09/02/Swagger-UI%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2020/09/02/Swagger-UI%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="swagger-ui放到线上运行时测试的url仍显示127-0-0-1"><a href="#swagger-ui放到线上运行时测试的url仍显示127-0-0-1" class="headerlink" title="swagger-ui放到线上运行时测试的url仍显示127.0.0.1"></a>swagger-ui放到线上运行时测试的url仍显示127.0.0.1</h1><p>需要在配置中加入如下配置，设置指定域名即可</p><p><img src="/2020/09/02/Swagger-UI%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/IPB7V08BUJ92M0H2ET67ELEKP.png" alt="图"></p><h1 id="报如下错误："><a href="#报如下错误：" class="headerlink" title="报如下错误："></a>报如下错误：</h1><p>java.lang.NumberFormatException:For input string:””</p><p>该错误是参数说明配置不完全导致 ，需要给定 example属性一个默认值</p>]]></content>
    
    
    
    <tags>
      
      <tag>问题总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot开发问题总结</title>
    <link href="/2020/09/02/SpringBoot%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2020/09/02/SpringBoot%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="拦截器配置不生效"><a href="#拦截器配置不生效" class="headerlink" title="拦截器配置不生效"></a>拦截器配置不生效</h1><p>配置拦截路径时不要包含上下文路径</p><h1 id="拦截器和跨域同时配置会出现冲突的问题"><a href="#拦截器和跨域同时配置会出现冲突的问题" class="headerlink" title="拦截器和跨域同时配置会出现冲突的问题"></a>拦截器和跨域同时配置会出现冲突的问题</h1><p>解决方案：不使用下面的方式</p><p><img src="/2020/09/02/SpringBoot%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/AA.png" alt="AA"></p><p>而使用这种方式<br><img src="/2020/09/02/SpringBoot%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/BB.png" alt="BB"></p><h1 id="SpringBoot分模块项目用-Autowired注解扫描不到部分包中的类"><a href="#SpringBoot分模块项目用-Autowired注解扫描不到部分包中的类" class="headerlink" title="SpringBoot分模块项目用@Autowired注解扫描不到部分包中的类"></a>SpringBoot分模块项目用@Autowired注解扫描不到部分包中的类</h1><p>尝试把SpringBoot启动类放在父级包中即可</p><h1 id="SpringBoot中使用拦截器后swagger-ui无法访问"><a href="#SpringBoot中使用拦截器后swagger-ui无法访问" class="headerlink" title="SpringBoot中使用拦截器后swagger-ui无法访问"></a>SpringBoot中使用拦截器后swagger-ui无法访问</h1><p>在拦截器配置中加入如下配置即可</p><pre><code class="hljs java">.excludePathPatterns(<span class="hljs-string">&quot;/swagger-resources/**&quot;</span>,<span class="hljs-string">&quot;/webjars/**&quot;</span>,<span class="hljs-string">&quot;/v2/**&quot;</span>,<span class="hljs-string">&quot;/swagger-ui.html/**&quot;</span>);</code></pre><h1 id="SpringBoot2-0后classpath中的静态文件无法访问"><a href="#SpringBoot2-0后classpath中的静态文件无法访问" class="headerlink" title="SpringBoot2.0后classpath中的静态文件无法访问"></a>SpringBoot2.0后classpath中的静态文件无法访问</h1><p><img src="/2020/09/02/SpringBoot%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/CC.png" alt="CC"></p>]]></content>
    
    
    
    <tags>
      
      <tag>问题总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch问题总结</title>
    <link href="/2020/09/02/ElasticSearch%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2020/09/02/ElasticSearch%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-从5-0开始，Elasticsearch的docker镜像不再支持开箱即用集群模式-，需要在启动时加入一下参数进行设置"><a href="#1-从5-0开始，Elasticsearch的docker镜像不再支持开箱即用集群模式-，需要在启动时加入一下参数进行设置" class="headerlink" title="1.从5.0开始，Elasticsearch的docker镜像不再支持开箱即用集群模式  ，需要在启动时加入一下参数进行设置"></a>1.从5.0开始，Elasticsearch的docker镜像不再支持开箱即用集群模式  ，需要在启动时加入一下参数进行设置</h1><h2 id="docker-run-d-–name-elas-elasticsearch-Etransport-host-0-0-0-0-Ediscovery-zen-minimum-master-nodes-1"><a href="#docker-run-d-–name-elas-elasticsearch-Etransport-host-0-0-0-0-Ediscovery-zen-minimum-master-nodes-1" class="headerlink" title="docker run -d –name elas elasticsearch -Etransport.host=0.0.0.0 -Ediscovery.zen.minimum_master_nodes=1"></a>docker run -d –name elas elasticsearch -Etransport.host=0.0.0.0 -Ediscovery.zen.minimum_master_nodes=1</h2><h2 id="设置后会报一个错误-1-max-virtual-memory-areas-vm-max-map-count-65530-is-too-low-increase-to-at-least-262144"><a href="#设置后会报一个错误-1-max-virtual-memory-areas-vm-max-map-count-65530-is-too-low-increase-to-at-least-262144" class="headerlink" title="设置后会报一个错误[1]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]"></a>设置后会报一个错误[1]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</h2><h3 id="需要在Linux下修改虚拟机内存大小限制"><a href="#需要在Linux下修改虚拟机内存大小限制" class="headerlink" title="需要在Linux下修改虚拟机内存大小限制"></a>需要在Linux下修改虚拟机内存大小限制</h3><h3 id="sysctl-w-vm-max-map-count-262144"><a href="#sysctl-w-vm-max-map-count-262144" class="headerlink" title="sysctl -w vm.max_map_count=262144"></a>sysctl -w vm.max_map_count=262144</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL问题总结</title>
    <link href="/2020/09/02/MySQL%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2020/09/02/MySQL%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL启动不成功"><a href="#MySQL启动不成功" class="headerlink" title="MySQL启动不成功"></a>MySQL启动不成功</h1><p>首先需要查看log，看报错信息，一般问题报的很直接  log文件夹存在于/var/log的文件夹下叫mysqld.log</p><h2 id="如果报如下问题"><a href="#如果报如下问题" class="headerlink" title="如果报如下问题"></a>如果报如下问题</h2><pre><code>2018-08-20T16:55:31.552860Z 0 [ERROR] Can&#39;t start server : Bind on unix socket: Address already in use2018-08-20T16:55:31.552873Z 0 [ERROR] Do you already have another mysqld server running on socket: /var/lib/mysql/mysql.sock ?</code></pre><p>需要查看/var/lib/mysql/mysql.sock文件是否存在  存在就删除  若存在mysql.sock.lock一并删除</p><h1 id="MySQL在Window系统中配置文件的存储路径"><a href="#MySQL在Window系统中配置文件的存储路径" class="headerlink" title="MySQL在Window系统中配置文件的存储路径"></a>MySQL在Window系统中配置文件的存储路径</h1><pre><code>C:\ProgramData\MySQL\MySQL Server 8.0</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>微信开发问题总结</title>
    <link href="/2020/09/02/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2020/09/02/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="调用微信授权接口后获取微信用户的信息时失败问题再现"><a href="#调用微信授权接口后获取微信用户的信息时失败问题再现" class="headerlink" title="调用微信授权接口后获取微信用户的信息时失败问题再现"></a>调用微信授权接口后获取微信用户的信息时失败问题再现</h1><pre><code>1  首次使用 scope=snsapi_base 进行网页授权2  拿到 code 后调用接口 https://api.weixin.qq.com/sns/oauth2/access_token?appid=&#123;0&#125;&amp;secret=&#123;1&#125;&amp;code=&#123;2&#125;&amp;grant_type=authorization_code3  根据上一步获取的 openid 和 access_token 调用接口 https://api.weixin.qq.com/sns/userinfo?access_token=&#123;0&#125;&amp;openid=&#123;1&#125;&amp;lang=zh_CN 获取用户基本信息4  获取失败：返回 &#123;&quot;errcode&quot;:48001,&quot;errmsg&quot;:&quot;api unauthorized, hints: [ req_id: 1QoCla0699ns81 ]&quot;&#125;</code></pre><p> 失败原因scope=snsapi_base 时，只能用于获取openid，不能获取用户的基本信息（获取用户信息，需要用户同意。<br> scope=snspai_base 授权时，并没有征求用户同意授权这一操作）</p><p> 说明：</p><pre><code> https://api.weixin.qq.com/sns/oauth2/access_token接口可以直接获取到用户的openid</code></pre><h1 id="支付不成功报返回如下错误chooseWXPay-fail-the-permission-value-is-offline-verifying"><a href="#支付不成功报返回如下错误chooseWXPay-fail-the-permission-value-is-offline-verifying" class="headerlink" title="支付不成功报返回如下错误chooseWXPay:fail, the permission value is offline verifying"></a>支付不成功报返回如下错误chooseWXPay:fail, the permission value is offline verifying</h1><p>是因为在微信支付控制台中没有配置JSAPI授权访问路径，配置正确路径即可，有一定延迟，需要等待生效（半小时左右）</p><h1 id="使用HTTPClient偶现-api-weixin-qq-com-443-failed-to-respond-问题"><a href="#使用HTTPClient偶现-api-weixin-qq-com-443-failed-to-respond-问题" class="headerlink" title="使用HTTPClient偶现 api.weixin.qq.com:443 failed to respond 问题"></a>使用HTTPClient偶现 api.weixin.qq.com:443 failed to respond 问题</h1><p>是因为 HTTPClient4.4版本的bug  升级至4.4.1即可</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat问题总结</title>
    <link href="/2020/09/02/Tomcat%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2020/09/02/Tomcat%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="The-valid-characters-are-defined-in-RFC-7230-and-RFC-3986"><a href="#The-valid-characters-are-defined-in-RFC-7230-and-RFC-3986" class="headerlink" title="The valid characters are defined in RFC 7230 and RFC 3986"></a>The valid characters are defined in RFC 7230 and RFC 3986</h1><p>发生该问题说明Tomcat对Url参数进行了验证<br>解决方案：</p><p>在catalina.properties 文件中添加如下配置</p><pre><code class="hljs properties"><span class="hljs-meta">tomcat.util.http.parser.HttpParser.requestTargetAllow</span>=<span class="hljs-string">\|&#123;&#125;</span></code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Nacos问题总结</title>
    <link href="/2020/09/02/Nacos%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2020/09/02/Nacos%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Nacos默认不支持MySQL-8-0以上"><a href="#Nacos默认不支持MySQL-8-0以上" class="headerlink" title="Nacos默认不支持MySQL 8.0以上"></a>Nacos默认不支持MySQL 8.0以上</h1><p>解决方案： ①下载源码升级mysql版本重新编译软件<br>          ②使用MySQL5.7</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux问题总结</title>
    <link href="/2020/09/02/Linux%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93-1/"/>
    <url>/2020/09/02/Linux%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Vmware虚拟机安装CentOSlinux最小化系统后无法上网"><a href="#Vmware虚拟机安装CentOSlinux最小化系统后无法上网" class="headerlink" title="Vmware虚拟机安装CentOSlinux最小化系统后无法上网"></a>Vmware虚拟机安装CentOSlinux最小化系统后无法上网</h1><p>需要修改网卡设置</p><pre><code class="hljs shell">cd /etc/sysconfig/network-scriptvim ifcfg-ens33（名称有可能不同）  修改 ONBOOT=yes</code></pre><h1 id="Vmware虚拟机安装后无法进行SSH远程访问（测试环境Ubuntu18）"><a href="#Vmware虚拟机安装后无法进行SSH远程访问（测试环境Ubuntu18）" class="headerlink" title="Vmware虚拟机安装后无法进行SSH远程访问（测试环境Ubuntu18）"></a>Vmware虚拟机安装后无法进行SSH远程访问（测试环境Ubuntu18）</h1><p>解决方法</p><pre><code>        ①检查防火墙设置并对端口进行放行        ②检查是否安装了ssh-server 如果没有安装则需要进行安装</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
